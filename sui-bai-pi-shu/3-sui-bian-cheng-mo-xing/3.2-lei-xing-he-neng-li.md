# 3.2 类型和能力

| PrimType =      | {address_,_ id_,_ bool_,_ u8_,_ u64_, . . ._}                |
| --------------- | ------------------------------------------------------------ |
| StructType =    | <p>ModuleName × StructName×</p><p>[StorableType]</p>         |
| StorableType =  | <p>PrimType ⊎ StructType⊎</p><p>GenericType ⊎ VectorType</p> |
| VectorType =    | StorableType                                                 |
| GenericType =   | N                                                            |
| MutabilityQual= | {mut_,_ immut}                                               |
| ReferenceType=  | StorableType × MutabilityQual                                |
| Type =          | ReferenceType ⊎ StorableType                                 |
| Ability =       | {key_,_ store_,_ copy_,_ drop}                               |

表 2：类型和能力

Move 程序处理存储在 Sui 全局对象池中的数据和 Move 程序执行时创建的瞬态数据。 对象和瞬态数据都是语言级别的移动值。 然而，并非所有的值都是平等的——它们可能具有不同的属性和不同的结构，正如它们的类型所规定的那样。

Move 中使用的类型在表 2 中定义。Move 支持许多其他编程中支持的基本类型语言，例如布尔类型或各种大小的无符号整数类型。此外，核心 Move 具有代表系统中最终用户的地址类型，该地址类型也用于识别交易的发送者和（在 Sui 中）对象的所有者。最后，Sui 定义了一个 id 类型，表示一个 Sui 对象的身份——详见第 3.3 节。

结构类型描述了在给定模块中声明的结构的实例（即值）（有关结构声明的信息，请参见第 3.1 节）。表示泛型结构声明（即泛型结构类型）的结构类型包括可存储类型的列表——该列表与结构声明中的泛型参数列表相对应。可存储类型可以是具体类型（原始类型或结构）或泛型类型。我们称此类类型为可存储的，因为它们可以作为结构的字段和持久存储在链上的对象出现，而引用类型则不能。

例如，Wrapper\<u64> 结构类型是一个用具体（原始）可存储类型 u64 参数化的通用结构类型——这种类型可用于创建结构实例（即值）。另一方面，相同的泛型结构类型可以用来自封闭结构或函数声明的泛型参数的泛型类型（例如，struct Parent\<T> { w: Wrapper\<T> }）进行参数化——这种type 可用于声明结构字段、函数参数等。在结构上，泛型类型是封闭结构或函数声明中泛型参数列表中的整数索引（在表 5 中定义为 N）。

Move 中的向量类型描述了同质值的可变长度集合。一个 Move 向量只能包含可存储类型，它本身也是可存储类型。

Move 程序可以直接对值进行操作，也可以通过引用间接访问它们。引用类型包括引用的可存储类型和可变性限定符，用于确定（和强制执行）给定类型的值是可以读取和写入（mut）还是只能读取（immut）。因此，Move 值类型（表 2 中的类型）的最一般形式可以是可存储类型或引用类型。

最后，Move 中的能力控制给定类型的值允许哪些操作，例如是否可以复制给定类型的值。能力约束结构声明和泛型类型参数。移动字节码验证器负责确保像副本这样的敏感操作只能在具有相应能力的类型上执行。
