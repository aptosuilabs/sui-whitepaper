# 3.1 Modules

| Module =      | <p>ModuleName×</p><p>(StructName <em>⇀</em> StructDecl)×</p><p>(FunName <em>⇀</em> FunDecl) × FunDecl</p> |
| ------------- | --------------------------------------------------------------------------------------------------------- |
| GenericParam= | \[Ability]                                                                                                |
| StructDecl =  | <p>(FieldName <em>⇀</em> StorableType)×</p><p>[Ability] × [GenericParam]</p>                              |
| FunDecl =     | \[Type]\[Type] × \[Instr] × \[GenericParam]                                                               |
| Instr =       | TransferToAddr \| TransferToObj \| ShareMut \| ShareImmut \| _. . ._                                      |

表 1：模块

移动代码被组织成模块，其结构在表 1 中定义。模块由命名结构声明的集合和命名函数声明的集合组成（这些声明的示例在第 2.1 节中提供）。模块还包含一个特殊的函数声明，用作模块初始化器。该函数在模块发布到链上时只调用一次。

结构声明是命名字段的集合，其中字段名称映射到可存储类型。它的声明还包括一个可选的能力列表（有关可存储类型和能力的描述，请参见第 2 节）。一个结构体声明还可以包含一个具有能力约束的泛型参数列表，在这种情况下，我们称其为泛型结构体声明，例如 struct Wrapper\<T: copy>{ t: T }。泛型参数表示声明结构字段时要使用的类型——在声明结构时它是未知的，在实例化结构时提供具体类型（即，在创建结构值时）。

函数声明包括参数类型列表、返回类型列表和构成函数主体的指令列表。一个函数声明还可以包含一个具有能力约束的泛型参数列表，在这种情况下，我们称之为泛型函数声明，例如 fun unwrap\<T: copy>(p: Wrapper\<T>){}。与结构声明类似，泛型参数表示在函数声明时未知的类型，但在声明函数参数、返回值和函数体时仍然使用它（调用函数时提供具体类型）。

可以出现在函数体中的指令包括所有普通的移动指令，但全局存储指令除外（例如，move\_to、move\_from、borrow\_global）。有关核心 Move 指令及其语义的完整列表，请参见 \[14]。 In Sui 通过 Sui 的全局对象池支持持久存储，而不是核心 Move 的基于帐户的全局存储。

有四种特定于 Sui 的对象操作。这些操作中的每一个都会更改对象的所有权元数据（参见第 3.3 节）并将其返回到全局对象池。最简单的是，一个 Sui 对象可以转移到一个 Sui 最终用户的地址。一个对象也可以转移到另一个父对象——这个操作需要调用者提供一个对父对象和子对象的可变引用。一个对象可以可变地共享，因此它可以被 Sui 系统中的任何人读/写。最后，一个对象可以被不可变地共享，所以它可以被 Sui 系统中的任何人读取，但不能被任何人写入。

区分不同所有权的能力是隋的一个独特特征。在我们知道的其他区块链平台中，每个合约和对象都是可变共享的。正如我们将在第 4 节中解释的那样，Sui 将这些信息用于并行事务执行（对于所有事务）和并行协议（对于涉及没有共享可变性的对象的事务）。
