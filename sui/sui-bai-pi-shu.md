# SUI白皮书

Sui 智能合约平台

MystenLabs 团队 hello@mystenlabs.com

**1 .简介**

Sui 是一个去中心化的无许可智能合约平台，偏向于资产的低延迟管理。它使用 Move 编程语言将资产定义为可能由地址拥有的对象。移动程序定义了对这些类型对象的操作，包括创建它们的自定义规则、将这些资产转移给新所有者以及改变资产的操作。

Sui 由一组未经许可的权限维护，这些权限的作用类似于其他区块链系统中的验证者或矿工。它在权限之间使用拜占庭一致的广播协议，以确保对资产的共同操作的安全性，与拜占庭协议相比，确保更低的延迟和更好的可扩展性。它只依赖拜占庭协议来保证共享对象的安全。以及治理操作和检查点，在关键延迟路径上执行。在可能的情况下，智能合约的执行自然也是并行的。 Sui 支持可以验证读取的轻客户端以及可以审核所有转换的完整性的完整客户端。这些设施允许与其他区块链的信任最小化桥梁。

原生资产 SUI 用于支付所有操作的 gas。它的所有者还使用它来将权益委托给当局以在 epoch 内操作 Sui，并且定期根据委托给他们的权益重新配置权限。使用过的天然气根据他们的股份和他们对 Sui 运营的贡献分配给当局及其代表。

本白皮书分为两部分，Sect. 2 描述了使用 Move 语言和 Sect 的 Sui 编程模型。 4 描述了确保 Sui 安全、活跃和性能的去中心化系统的操作。

**2 .SUI 智能合约编程**

Sui 智能合约是用 Move\[4] 语言编写的。 Move 安全且富有表现力，其类型系统和数据模型自然支持使 Sui 可扩展的并行协议/执行策略。 Move 是一种用于构建智能合约的开源编程语言，最初是在 Facebook 为 Diem 区块链开发的。 该语言与平台无关，除了被 Sui 采用之外，它在其他平台（例如 0L、StarCoin）上也越来越受欢迎。

在本节中，我们将讨论 Move 语言的主要特性，并解释如何使用它在 Sui 上创建和管理资产。 可以在 Move 编程语言书和更多 Sui-具体的 Move 内容可以在 Sui 开发者门户中找到，关于 Sui 上下文中 Move 的更正式的描述可以在第 3 节中找到。

2.1 概述

Sui 的全局状态包括一个由 Move 包创建和管理的可编程对象池，这些包是包含 Move 函数和类型的 Move 模块的集合（详见第 2.1.1 节）。 移动包本身也是对象。 因此，Sui 对象可以分为两类：

• 结构数据值：由移动模块管理的类型化数据。 每个对象都是一个结构值，其字段可以包含原始类型（例如整数、地址）、其他对象和非对象结构。

• 包代码值：作为原子单元发布的一组相关移动字节码模块。 包中的每个模块既可以依赖于该包中的其他模块，也可以依赖于先前发布的包中的模块.

对象可以对资产进行编码（例如，可替代或不可替代的代币）、授予调用某些函数或创建其他对象的权限的能力、管理其他资产的“智能合约”等等——由程序员决定。 声明自定义 Sui 对象类型的 Move 代码如下所示：

struct Obj has key {\
id: VersionedID, // globally unique ID and version\
f: u64 // objects can have primitive fields\
g: OtherObj // fields can also store other objects\
}

所有表示 Sui 对象的结构体（但不是所有 Move 结构体值）都必须具有 id 字段和指示该值可以存储在 Sui 的全局对象池中的 key 能力。

2.1.1 模块: 一个 Move 程序被组织成一组模块，每个模块都包含一个结构声明和函数声明的列表。 一个模块可以从其他模块导入结构类型并调用其他模块声明的函数。

在一个 Move 模块中声明的值可以流入另一个模块——

例如，上面示例中的模块 OtherObj 可以在与定义 Obj 的模块不同的模块中定义。 这与大多数智能合约语言不同，后者只允许非结构化字节跨合约边界流动。 然而，Move 能够支持这一点，因为它提供了封装特性来帮助程序员编写健壮安全的 \[14] 代码。 具体来说，Move 的类型系统确保像上面的 Obj 这样的类型只能由以下人员创建、销毁、复制、读取和写入声明类型的模块内的函数。 这允许模块对其声明的类型强制执行强不变量，即使它们流过智能合约信任边界，它们也会继续保持不变。

2.1.2 事务和入口点: 全局对象池通过可以创建、销毁、读取和写入对象的事务进行更新。 事务必须将它希望操作的每个现有对象作为输入。 此外，事务必须包括包对象的版本 ID、包内的模块和函数的名称以及函数的参数（包括输入对象）。 例如，调用函数

public fun entrypoint(\
o1: Obj, o2: \&mut Obj, o3: \&Obj, x: u64, ctx: \&mut TxContext\
) { ... }

一个事务必须为三个不同的对象提供 ID，它们的类型是 Obj 和一个要绑定到 x 的整数。 TxContext 是由运行时填充的特殊参数，其中包含发送者地址和创建新对象所需的信息。

入口点的输入（更一般地说，任何 Move 函数）的输入可以使用类型中编码的不同可变性权限进行传递。 可以读取、写入、传输或销毁 Obj 输入。 \&mut Obj 输入只能读取或写入，\&Obj 只能读取。 交易发送者必须被授权使用具有指定可变性权限的每个输入对象——有关更多详细信息，请参见第 4.4 节。

2.1.3 创建和传输对象: 程序员可以通过使用传入入口点的 TxContext 为对象生成新的 ID 来创建对象：

public fun create\_then\_transfer(\
f: u64, g: OtherObj, o1: Obj, ctx: \&mut TxContext\
) {\
let o2 = Obj { id: TxContext::fresh\_id(ctx), f, g };\
Transfer::transfer(o1, TxContext:sender());\
Transfer::transfer(o2, TxContext:sender());\
}

此代码以 OtherObj 和 Obj 类型的两个对象作为输入，使用第一个对象和生成的 ID 创建一个新的 Obj，然后将这两个 Obj 对象传输给交易发送者。 一旦一个对象被转移，它就会流入全局对象池，并且在事务的其余部分中不能被代码访问。 Transfer 模块是 Sui 标准库的一部分，其中包括将对象传输到用户地址和其他对象的函数。

我们注意到，如果程序员代码忽略包含其中一个传输调用，则此代码将被 Move 类型系统拒绝。 Move 强制执行资源安全 \[5] 保护，以确保无法在未经许可的情况下创建对象、复制对象或意外销毁对象。 资源安全的另一个例子是尝试传输同一个对象两次，这也将被 Move 类型系统拒绝。

**3 SUI 编程模型**

在本节中，我们通过提供详细的语义定义来扩展第 2 节中对 Sui 编程模型的非正式描述。 上一节展示了 Move 源代码的示例； 这里我们定义了 Move 字节码的结构。 开发人员编写、测试和形式验证 \[10, 16] 在本地移动源代码，然后将其编译为移动字节码，然后再发布到区块链。 任何在链上发布的 Move 字节码都必须通过字节码验证器\[4, 5] 以确保其满足类型、内存和资源安全等关键属性。

如第 2 节所述，Move 是一种与平台无关的语言，无需分叉核心语言即可适应不同系统的特定需求。 在以下描述中，我们定义了核心 Move 语言（用黑色文本表示）和扩展核心 Move 语言（用橙色文本表示）的 Sui 特定功能的两个概念。

### Modules

| Module =      | <p>ModuleName×</p><p>(StructName <em>⇀</em> StructDecl)×</p><p>(FunName <em>⇀</em> FunDecl) × FunDecl</p> |
| ------------- | --------------------------------------------------------------------------------------------------------- |
| GenericParam= | \[Ability]                                                                                                |
| StructDecl =  | <p>(FieldName <em>⇀</em> StorableType)×</p><p>[Ability] × [GenericParam]</p>                              |
| FunDecl =     | \[Type]\[Type] × \[Instr] × \[GenericParam]                                                               |
| Instr =       | TransferToAddr \| TransferToObj \| ShareMut \| ShareImmut \| _. . ._                                      |

表 1：模块

移动代码被组织成模块，其结构在表 1 中定义。模块由命名结构声明的集合和命名函数声明的集合组成（这些声明的示例在第 2.1 节中提供）。模块还包含一个特殊的函数声明，用作模块初始化器。该函数在模块发布到链上时只调用一次。

结构声明是命名字段的集合，其中字段名称映射到可存储类型。它的声明还包括一个可选的能力列表（有关可存储类型和能力的描述，请参见第 2 节）。一个结构体声明还可以包含一个具有能力约束的泛型参数列表，在这种情况下，我们称其为泛型结构体声明，例如 struct Wrapper\<T: copy>{ t: T }。泛型参数表示声明结构字段时要使用的类型——在声明结构时它是未知的，在实例化结构时提供具体类型（即，在创建结构值时）。

函数声明包括参数类型列表、返回类型列表和构成函数主体的指令列表。一个函数声明还可以包含一个具有能力约束的泛型参数列表，在这种情况下，我们称之为泛型函数声明，例如 fun unwrap\<T: copy>(p: Wrapper\<T>){}。与结构声明类似，泛型参数表示在函数声明时未知的类型，但在声明函数参数、返回值和函数体时仍然使用它（调用函数时提供具体类型）。

可以出现在函数体中的指令包括所有普通的移动指令，但全局存储指令除外（例如，move\_to、move\_from、borrow\_global）。有关核心 Move 指令及其语义的完整列表，请参见 \[14]。 In Sui 通过 Sui 的全局对象池支持持久存储，而不是核心 Move 的基于帐户的全局存储。

有四种特定于 Sui 的对象操作。这些操作中的每一个都会更改对象的所有权元数据（参见第 3.3 节）并将其返回到全局对象池。最简单的是，一个 Sui 对象可以转移到一个 Sui 最终用户的地址。一个对象也可以转移到另一个父对象——这个操作需要调用者提供一个对父对象和子对象的可变引用。一个对象可以可变地共享，因此它可以被 Sui 系统中的任何人读/写。最后，一个对象可以被不可变地共享，所以它可以被 Sui 系统中的任何人读取，但不能被任何人写入。

区分不同所有权的能力是隋的一个独特特征。在我们知道的其他区块链平台中，每个合约和对象都是可变共享的。正如我们将在第 4 节中解释的那样，Sui 将这些信息用于并行事务执行（对于所有事务）和并行协议（对于涉及没有共享可变性的对象的事务）。

### 类型和能力

| PrimType =      | {address_,_ id_,_ bool_,_ u8_,_ u64_, . . ._}                |
| --------------- | ------------------------------------------------------------ |
| StructType =    | <p>ModuleName × StructName×</p><p>[StorableType]</p>         |
| StorableType =  | <p>PrimType ⊎ StructType⊎</p><p>GenericType ⊎ VectorType</p> |
| VectorType =    | StorableType                                                 |
| GenericType =   | N                                                            |
| MutabilityQual= | {mut_,_ immut}                                               |
| ReferenceType=  | StorableType × MutabilityQual                                |
| Type =          | ReferenceType ⊎ StorableType                                 |
| Ability =       | {key_,_ store_,_ copy_,_ drop}                               |

表 2：类型和能力

Move 程序处理存储在 Sui 全局对象池中的数据和 Move 程序执行时创建的瞬态数据。 对象和瞬态数据都是语言级别的移动值。 然而，并非所有的值都是平等的——它们可能具有不同的属性和不同的结构，正如它们的类型所规定的那样。

Move 中使用的类型在表 2 中定义。Move 支持许多其他编程中支持的基本类型语言，例如布尔类型或各种大小的无符号整数类型。此外，核心 Move 具有代表系统中最终用户的地址类型，该地址类型也用于识别交易的发送者和（在 Sui 中）对象的所有者。最后，Sui 定义了一个 id 类型，表示一个 Sui 对象的身份——详见第 3.3 节。

结构类型描述了在给定模块中声明的结构的实例（即值）（有关结构声明的信息，请参见第 3.1 节）。表示泛型结构声明（即泛型结构类型）的结构类型包括可存储类型的列表——该列表与结构声明中的泛型参数列表相对应。可存储类型可以是具体类型（原始类型或结构）或泛型类型。我们称此类类型为可存储的，因为它们可以作为结构的字段和持久存储在链上的对象出现，而引用类型则不能。

例如，Wrapper\<u64> 结构类型是一个用具体（原始）可存储类型 u64 参数化的通用结构类型——这种类型可用于创建结构实例（即值）。另一方面，相同的泛型结构类型可以用来自封闭结构或函数声明的泛型参数的泛型类型（例如，struct Parent\<T> { w: Wrapper\<T> }）进行参数化——这种type 可用于声明结构字段、函数参数等。在结构上，泛型类型是封闭结构或函数声明中泛型参数列表中的整数索引（在表 5 中定义为 N）。

Move 中的向量类型描述了同质值的可变长度集合。一个 Move 向量只能包含可存储类型，它本身也是可存储类型。

Move 程序可以直接对值进行操作，也可以通过引用间接访问它们。引用类型包括引用的可存储类型和可变性限定符，用于确定（和强制执行）给定类型的值是可以读取和写入（mut）还是只能读取（immut）。因此，Move 值类型（表 2 中的类型）的最一般形式可以是可存储类型或引用类型。

最后，Move 中的能力控制给定类型的值允许哪些操作，例如是否可以复制给定类型的值。能力约束结构声明和泛型类型参数。移动字节码验证器负责确保像副本这样的敏感操作只能在具有相应能力的类型上执行。

*
  1. 对象和所有权

| TxDigest =   | _𝐶𝑜𝑚_(Tx)                              |
| ------------ | ----------------------------------------- |
| ObjID =      | _𝐶𝑜𝑚_(TxDigest × N)                    |
| SingleOwner= | Addr ⊎ ObjID                              |
| Shared =     | {shared\_mut_,_ shared\_immut}            |
| Ownership =  | SingleOwner ⊎ Shared                      |
| StructObj =  | StructType × Struct                       |
| ObjContents= | StructObj ⊎ Package                       |
| Obj =        | ObjContents × ObjID × Ownership × Version |

表 3：对象和所有权

每个 Sui 对象都有一个全局唯一标识符（表 3 中的 ObjID），当它在所有者之间流动以及流入和流出其他对象时，它充当对象的持久标识。此 ID 由创建它的事务分配给对象。对象 ID 是通过对当前事务的内容和记录事务创建了多少对象的计数器应用抗冲突哈希函数来创建的。由于对交易的输入对象的限制，交易（以及它的摘要）保证是唯一的，我们将在后面解释。

除了 ID 之外，每个对象还携带有关其所有权的元数据。一个对象要么由一个地址或另一个对象唯一拥有，要么以写/读权限共享，要么仅以读权限共享。对象的所有权决定了交易是否以及如何将其用作输入。从广义上讲，唯一拥有的对象只能用于由其所有者发起的事务或将其父对象作为输入，而共享对象可以由任何事务使用，但只能具有指​​定的可变性权限。有关完整说明，请参见第 4.4 节。

有两种类型的对象：包代码对象和结构数据对象。一个包对象包含一个模块列表。结构对象包含一个 Move 结构值和该值的 Move 类型。

对象的内容可能会改变，但其 ID、对象类型（包与结构）和移动结构类型是不可变的。这确保了对象是强类型并具有持久标识。

最后，一个对象包含一个版本。新创建的对象的版本为 0，每次事务将对象作为输入时，对象的版本就会递增。

*
  1. 地址和验证器.

| Authenticator= | Ed25519PubKey ⊎ ECDSAPubKey ⊎ _. . ._ |
| -------------- | ------------------------------------- |
| Addr =         | _𝐶𝑜𝑚_(Authenticator)               |

表 4：地址和身份验证器

地址是 Sui 最终用户的永久身份（尽管请注意，单个用户可以拥有任意数量的地址）。 要将对象传输给另一个用户，发送者必须知道接收者的地址。

正如我们稍后将讨论的那样，Sui 交易必须包含发送（即发起）交易的用户的地址以及其摘要与地址匹配的身份验证器。 地址和身份验证器之间的分离实现了加密敏捷性。 验证器可以是来自任何签名方案的公钥，即使这些方案使用不同的密钥长度（例如，支持后量子签名）。 此外，验证器不必是单个公钥——它也可以是（例如）一个 K-of-N 多重签名密钥。

*
  1. 交易

| ObjRef =     | ObjID × Version × _𝐶𝑜𝑚_(Obj)                   |
| ------------ | ------------------------------------------------- |
| CallTarget = | ObjRef × ModuleName × FunName                     |
| CallArg =    | ObjRef ⊎ ObjID ⊎ PrimType                         |
| Package =    | \[Module]                                         |
| Publish =    | Package × \[ObjRef]                               |
| Call =       | CallTarget × \[StorableType] × \[CallArg]         |
| GasInfo =    | ObjRef × MaxGas × BaseFee × Tip                   |
| Tx =         | (Call ⊎ Publish) × GasInfo × Addr × Authenticator |

表 5：交易

Sui 有两种不同的事务类型：发布新的 Move 包和调用之前发布的 Move 包。发布事务包含一个包——一组将作为单个对象一起发布的模块，以及此包中所有模块的依赖关系（编码为对象引用列表，必须引用已发布的包对象）。为了执行发布事务，Sui 运行时将在每个包上运行移动字节码验证器，将包与其依赖项链接起来，并运行每个模块的模块初始化程序。模块初始化器对于引导由包实现的应用程序的初始状态很有用。

调用事务最重要的参数是对象输入。对象参数可以通过对象引用（对于单一所有者和共享的不可变对象）或对象 ID（对于共享可变对象）。对象引用由对象 ID、对象版本和对象值的散列组成。 Sui 运行时会将对象 ID 和对象引用解析为存储在全局对象池中的对象值。对于对象引用，运行时将根据池中对象的版本检查引用的版本，并检查引用的哈希是否与池对象匹配。这确保了运行时对象的视图与事务发送者的对象视图相匹配。

此外，调用事务接受类型参数和纯值参数。类型参数实例化要调用的入口点函数的泛型类型参数（例如，如果入口点函数是 send\_coin\<T>(c: Coin\<T>, ...)，则可以使用类型参数来实例化泛型类型参数 T SUI 发送 Sui 原生令牌）。纯值可以包括原始类型和原始类型的向量，但不包括结构类型。

调用要调用的函数通过对象引用（必须引用包对象）、该包中的模块名称和该包中的函数名称来指定。为了执行调用事务，Sui 运行时将解析函数，将类型、对象和值参数绑定到函数参数，并使用 Move VM 执行函数。

调用和发布交易均需支付燃气计量和燃气费。 计量限制由最大气体预算表示。 运行时将执行事务，直到达到预算，如果预算用尽，将中止（除了扣除费用和报告中止代码）。

费用从指定为对象参考的气体对象中扣除。 该对象必须是 Sui 原生令牌（即，其类型必须是 Coin\<SUI>）。 Sui 使用 EIP1559 式的费用：协议定义了一个基本费用（以每个 Sui 代币的 gas 单位计价），该费用在 epoch 边界通过算法进行调整，并且交易发送者还可以包括一个可选的小费（以 Sui 代币计价）。 在正常系统负载下，即使没有小费，交易也会得到及时处理。 但是，如果系统拥塞，小费较大的交易将被优先处理。 从 gas 对象中扣除的总费用为 (GasUsed ∗ BaseFee) + Tip。

*
  1. **交易效果**

| Event =         | StructType × Struct             |
| --------------- | ------------------------------- |
| Create =        | Obj                             |
| Update =        | Obj                             |
| Wrap =          | ObjID × Version                 |
| Delete =        | ObjID × Version                 |
| ObjEffect =     | Create ⊎ Update ⊎ Wrap ⊎ Delete |
| AbortCode =     | N × ModuleName                  |
| SuccessEffects= | \[ObjEffect] × \[Event]         |
| AbortEffects =  | AbortCode                       |
| TxEffects =     | SuccessEffects ⊎ AbortEffects   |

**表 6：交易影响**

事务执行产生的事务效果在事务执行成功的情况下是不同的（表 6 中的 SuccessEffects）和失败时（表 6 中的 AbortEffects）。

成功执行事务后，事务影响包括有关对 Sui 的全局对象池所做的更改（包括对现有对象和新创建的对象的更新）和事务执行期间生成的事件的信息。成功执行事务的另一个效果可能是从全局池中删除（即删除）对象，并将一个对象包装（即嵌入）到另一个对象中，这与删除具有相似的效果——一个被包装的对象从全局池中消失并存在仅作为包装它的对象的一部分。由于已删除和包装的对象在全局池中不再可访问，因此这些效果由对象的 ID 和版本表示。

事件对成功执行事务的副作用进行编码，而不是对全局对象池的更新。在结构上，事件由 Move 结构及其类型组成。事件旨在由区块链之外的参与者使用，但不能被 Move 程序读取。

Move 中的事务具有全有或全无的语义——如果事务的执行在某个时刻中止（例如，由于意外失败），即使在此之前已经发生了对对象的一些更改（或已经生成了一些事件） 点，这些影响都不会在中止的事务中持续存在。 相反，中止事务效果包括数字中止代码和发生事务中止的模块的名称。 中止的交易仍会收取 Gas 费。

1. **SUI系统**

在本节中，我们从系统的角度描述 Sui，包括在拜占庭式失败的情况下确保跨部门安全和活跃性的机制。我们还解释了客户端的操作，包括需要对系统状态进行一些保证而不验证其完整状态的轻客户端。

简要背景。在系统级别上，Sui 是 FastPay \[3] 低延迟结算系统的演变，通过用户定义的智能合约扩展为对任意对象进行操作，并具有未经许可的委托权益委员会组成证明 \[2]。对象所有者的基本资产管理基于拜占庭一致广播 \[6] 的一种变体，与拜占庭共识的传统实现 \[8,11,12] 相比，它具有更低的延迟并且更容易在许多机器上进行扩展。当完全一致时要求我们使用基于 DAG 的高吞吐量共识，例如\[9] 来管理锁，同时在不同的共享对象上并行执行。

协议大纲。图 1 说明了客户端和 Sui 当局之间的高级交互以提交事务。我们在这里简要描述它们：

• 具有私有签名密钥的用户创建并签署用户事务以改变他们在Sui 中拥有的对象或共享对象。随后，不再需要用户签名密钥，剩下的流程可以由用户客户端执行，也可以由网关代表用户执行（图中表示为无密钥操作）。

• 用户交易被发送到 Sui 当局，每个当局检查它的有效性，并在成功时对其进行签名并将签名的交易返回给客户端。客户端收集来自法定人数的授权以形成交易证书。

• 然后将交易证书发送回所有权威机构，如果交易涉及共享对象，它也会发送到由 Sui 权威机构操作的拜占庭协议协议。当局检查证书，如果涉及共享对象，还等待协议协议将其与其他共享对象事务相关的顺序，然后执行交易并将其影响汇总为签名的影响响应。

• 一旦权威机构的法定人数执行了证书，其效果就是最终的（在图中表示为最终性）。 客户可以收集法定人数的权威响应并创建效果证书，并将其用作交易效果最终确定性的证明。

本节详细描述了这些操作中的每一个，以及跨权限重新配置和管理状态的操作。

4.1 系统模型

Sui 在记为 𝑒 ∈ {0, . . .}。每个时期由一个委员会𝐶𝑒 = (𝑉𝑒,𝑆𝑒 (·)) 管理，其中𝑉𝑒 是一组具有已知公共验证密钥和网络端点的权限。函数 𝑆𝑒 (𝑣) 将每个权限 𝑣 ∈ 𝑉𝑒 映射到多个委托权益单位。我们假设每个纪元的𝐶𝑒由纪元𝑒 -1 的法定人数（见下文）签署。 （第 4.7 节讨论了委员会的组建和管理）。在一个时期内，一些权威是正确的（他们忠实地遵循协议并且是活的），而另一些是拜占庭的（他们任意偏离协议）。安全假设是诚实的权威集合𝐻𝑒 ⊆ 𝑉𝑒 在 epoch 内被分配了法定权益，即 Íℎ∈𝐻𝑒 𝑆𝑒 (ℎ) > 2/3 Í𝑣∈𝑉𝑒 𝑆𝑒 (𝑣)（并指任何权威集合超过三分之二的股份作为法定人数）。

在诚实的权威机构之间，至少存在一个有效且正确的一方作为每个证书的中继（参见第 4.3 节）。这确保了活跃性，并为拜占庭广播提供了最终交付属性（参见 \[6] 中的可靠广播的总体）。每个权威机构单独或通过集体传播协议运行这样的中继。包括 Sui 轻客户端、副本和服务在内的外部实体也可能担任此角色。被动权威核心与不太可靠或可信的内部或外部主动中继组件之间的区别确保了对 Sui 安全性和活跃性所依赖的可信计算库 \[15] 的明确划分和最小化。

4.2 权威和副本数据结构

隋当局依靠许多数据结构来表示状态。 我们根据它们支持的操作来定义这些结构。 它们都具有确定性的字节表示。

* 一个对象（Obj）在 Sui 中存储用户智能合约和数据。 它们是 Sect 中介绍的 Move 对象的 Sui 系统级编码。 2. 它们支持以下一组操作：
* _ref_(Obj) returns the _reference_ (ObjRef) of the object, namely a triplet (ObjID, Version, ObjDigest). ObjID is practically

![](../.gitbook/assets/0)

图 1：提交事务的交互概述。 对所有创建的新对象都是唯一的，而 Version 是一个递增的正整数，表示对象版本在发生变异时。

• owner(Obj) 返回对象所有者的认证者Auth。 在最简单的情况下，Auth 是一个地址，代表一个可以使用该对象的公钥。 还可以使用更复杂的身份验证器（参见第 4.4 节）。

• 如果对象是只读的，read-only(Obj) 返回真。 只读对象可能永远不会被变异、包装或删除。 它们也可能被任何人使用，而不仅仅是它们的所有者。

• parent(Obj) 返回上次改变或创建对象的事务摘要 (TxDigest)。

• contents(Obj) 返回对象类型 类型和数据 可用于检查交易有效性和携带对象的应用程序特定信息的数据。

对象引用 (ObjRef) 用于索引对象。它还用于验证对象，因为 ObjDigest 是对其全部内容的承诺。

事务 (Tx) 是一种结构，表示一个或多个对象的状态转换。它们支持以下一组操作：

• digest(Tx) 返回TxDigest，它是对交易的绑定加密承诺。

• epoch(Tx) 返回可以执行此事务的 EpochID。

• inputs(Tx) 返回事务需要执行的一系列对象\[ObjRef]。

• payment(Tx) 返回对用于支付gas 的ObjRef 的引用，以及最大gas 限制，以及gas 单位与gas 支付对象中的价值单位之间的转换率。

• 如果交易有效，valid(Tx, \[Obj]) 返回真，给定请求的输入对象。有效性在 Sect 中讨论。 4.4，并涉及授权对输入对象进行操作的交易，以及有足够的可用gas来支付其执行成本。

• exec(Tx, \[Obj]) 执行事务并返回表示其效果的结构Effects。有效的交易执行是绝对可靠的，其输出是确定性的。

交易由其 TxDigest 索引，也可用于验证其全部内容。所有有效的交易（除了特殊的硬编码创世交易）都有至少一个拥有的输入，即用于支付 gas 的对象。

交易效果（Effects）结构总结了交易执行的结果。它支持以下操作：

• digest(Effects) 是对Effects 结构的承诺EffDigest，可用于索引或验证它。

• transaction(Effects) 返回产生效果的已执行交易的 TxDigest。

• dependencies(Effects) 返回一系列依赖项\[TxDigest]，应该在具有这些效果的事务执行之前执行。

• contents(Effects) 返回执行摘要。状态报告智能合约执行的结果。 Created、Mutated、Wrapped、Unwrapped 和 Deleted 列表列出了进行了相应的操作。 Events 列出了执行发出的事件。

交易上的交易证书 TxCert 包含交易本身以及来自法定人数的标识符和签名。请注意，证书可能不是唯一的，因为相同的逻辑证书可能由形成法定人数的不同权限集表示。此外，证书可能不会严格由 2/3 的法定人数签署，但如果有更多的权威机构响应，则可能更多。但是，同一事务中的两个不同的有效证书应被视为在语义上表示相同的证书。部分证书 (TxSign) 包含相同的信息，但来自一组代表权益的机构的签名低于所需的法定人数，通常是单个机构。签名者的标识符包含在证书中（即负责的签名 \[? ]），以识别准备处理证书的机构，或者可用于下载处理证书所需的过去信息（参见第 4.8 节）。

类似地，效果结构上的效果证书 EffCert 包含效果结构本身，以及代表交易有效时期法定人数的权威机构的签名。关于非唯一性和身份的相同警告适用于交易证书。部分效果证书，通常包含单个授权签名，效果结构表示为 EffSign。

持久存储。每个权限和副本都维护一组持久存储。存储实现持久映射语义，可以表示为一组键值对（表示为

𝑚𝑎𝑝\[𝑘𝑒𝑦] → 𝑣𝑎𝑙𝑢𝑒），这样只有一对有给定的密钥。在插入一对之前， contains(𝑘𝑒𝑦) 调用返回 false，而 get(𝑘𝑒𝑦) 返回错误。插入一对之后， contains(𝑘𝑒𝑦) 调用返回 true，get(𝑘𝑒𝑦) 返回值。权限维护以下持久性存储：

• 订单锁映射 Lock𝑣 \[ObjRef] → TxSignOption 记录由权威机构为拥有的对象版本 ObjRef 看到并签名的第一个有效交易 Tx，或者如果对象版本存在但没有有效交易用作输入，则记录为无。它还可以记录与该对象一起看到的第一个证书作为输入。该表及其更新规则表示跨 Sui 权限的对象分布式锁的状态，并确保事务并发处理下的安全性。

• 证书映射 Ct𝑣 \[TxDigest] → (TxCert, EffSign) 记录所有完整证书 TxCert，其中还包括 Tx，由权威机构在其有效期内处理，以及它们的签名效果 EffSign。它们由交易摘要 TxDigest 索引

• 对象映射 Obj𝑣 \[ObjRef] → Obj 记录由 Ct𝑣 内证书中包含的事务创建的所有对象 Obj由 ObjRef 索引。通过重新执行 Ct𝑣 中的所有证书，可以完全导出此存储。维护一个二级索引，将 ObjID 映射到具有此 ID 的最新对象。这是处理新事务所需的唯一信息，维护旧版本只是为了方便读取和审计。

• 同步映射 Sync𝑣 \[ObjRef] → TxDigest 索引 Ct𝑣 内的所有证书，按它们创建、变异或删除的对象作为元组 ObjRef。通过处理 Ct𝑣 中的所有证书可以完全重新创建此结构，并用于帮助客户端同步影响他们关心的对象的事务。

权威机构维护所有四个结构，并提供对其证书映射的本地检查点的访问权限，以允许其他权威机构和副本下载其完整的已处理证书集。副本不处理事务而只处理证书，并像当局一样重新执行它们以更新其他表。它还维护一个订单锁映射以审计非模棱两可。

权限可以设计为维护所有四个存储（和检查点）以促进读取和同步的完整副本，并结合最小权限核心，该核心仅维护用于处理新事务和证书的最新版本对象的对象锁和对象。这最大限度地减少了安全所依赖的可信计算库。

只有顺序锁映射需要强键自一致性，即对键的读取应始终返回是否存在值或 None 对于存在的键，并且这种检查应该是原子的，并且更新将锁定设置为非无值。这是一个比键之间的强一致性更弱的属性，并且允许对存储进行有效的分片以进行扩展。其他商店可能最终一致而不影响安全。

4.3 权限库操作

处理事务。收到交易 Tx 后，授权机构会执行多项检查：

(1) 确保 epoch(Tx) 是当前 epoch。

(2) 它确保所有对象引用输入(Tx) 和支付(Tx) 中的气体对象引用存在于Obj𝑣 中，并将它们加载到\[Obj] 中。对于拥有的对象，应该有确切的参考；对于只读或共享对象，对象 ID 应该存在。

(3) 确保可以在气体对象中提供足够的气体来支付执行交易的成本。

(4) 检查valid(Tx, \[Obj]) 是否为真。此步骤确保事务中的身份验证信息允许访问拥有的对象。

(5) 它检查所有拥有的输入（Tx）对象的 Lock𝑣 \[ObjRef] 是否存在，它要么是 None 要么设置为相同的 Tx，并自动将其设置为 TxSign。 （我们称这些为“锁检查”）。

如果任何检查失败，则处理结束，并返回错误。但是，Lock𝑣 的部分更新持续存在是安全的（尽管我们当前的实现不做部分更新，而是对所有锁进行原子更新）。

如果所有检查都成功，则当局返回交易签名，即。部分证书 TxSign。成功处理订单是幂等的，并返回部分证书 (TxSign) 或完整证书 (TxCert)（如果可用）。

任何一方都可以为一组权限核对交易和签名（TxSign），形成一个纪元𝑒的法定人数，以形成交易证书 TxCert。

工艺证书。收到证书后，权威机构会检查交易的所有有效性条件，除了与锁相关的条件（所谓的“锁检查”）。相反，它执行以下检查：对于输入（Tx）中的每个拥有的输入对象，它检查锁是否存在，并且它是无，设置为任何 TxSign，或设置为与当前证书相同的交易的证书。如果此修改锁检查失败，则该权限已检测到不可恢复的拜占庭故障，停止正常操作，并启动灾难恢复过程。对于共享对象（参见第 4.4 节），当局检查锁定是否已通过在共识中排序的证书设置，以确定要使用的共享对象的版本。如果是这样，交易可能会被执行；否则需要先等待这样的排序。

如果检查成功，则授权将证书添加到其证书映射中，连同其执行产生的效果，即。 Ct𝑣 \[TxDigest] → (TxCert, EffSign);它更新锁映射以记录证书 Lock𝑣 \[ObjRef] → TxCert 用于所有拥有的未设置为证书的锁的输入对象。一旦 Input(Tx) 中的所有对象都插入到 Obj𝑣 中，那么 EffSign 中的所有效果也会通过将它们的 ObjRef 和内容添加到 Obj𝑣 来实现。最后，对于在 EffSign 中创建或变异的所有内容，同步映射会更新以将它们映射到 Tx。

评论。处理交易和证书的逻辑导致了许多重要的属性：

• 因果关系和平行性。交易和证书的处理条件确保因果执行：如果授权机构已经处理了创建交易所依赖的对象的所有证书（包括拥有的、共享的和只读的），那么它只会通过签署交易来“投票”。类似地，只有当它所依赖的所有输入对象都存在于它的本地对象映射中时，一个权威才会处理一个证书。这强加了因果执行顺序，但也使不存在因果关系的事务能够在不同的内核或机器上并行执行。

• 签名一次，安全。 Lock𝑣 \[·] 中所有拥有的输入对象锁被设置为第一个通过使用它们的检查的交易 Tx，然后是第一个使用它们的证书对象作为输入。我们称之为将对象锁定到该事务，并且在一个时期内没有解锁。因此，一个权限只为每个锁签署一个事务，这是一致广播 \[6] 的重要组成部分，因此也是 Sui 的安全性。

• 灾难恢复。一个权威机构检测到同一个锁的两个相互矛盾的证书，就有了不可恢复的拜占庭行为的证据——即证明法定人数诚实权威假设不成立。这两个相互矛盾的证书是欺诈证明 \[1]，可以与所有权限和副本共享以触发灾难恢复过程。当局还可以获得其他形式的不可恢复的拜占庭行为证明，例如 >1/3 的签名效果 (EffSign)，表示证书执行不正确。或者带有不代表先前处理的证书的正确输出的输入对象的证书。这些也可以打包为欺诈证明，并与所有权威机构和副本共享。请注意，这些与证明少数权威（≤ 1/3 的权益）或对象所有者（任意数量）是拜占庭式或模棱两可的证明不同，这可以在不中断服务的情况下被容忍。

• 确定性。当局为 Lock𝑣、Ct𝑣 和 Obj𝑣、Sync𝑣 中的索引的任何读取请求返回证书 (TxCert) 和签名效果 (EffSign)。如果超过法定人数的授权报告 Tx 包含在其 Ct𝑣 存储中，则交易被视为最终交易。这意味着效果证书 (EffCert) 是可转让的确定性证明。但是，使用对象的证书也证明其因果路径中的所有依赖证书也是最终的。向任何一方提供证书，然后该方可以将其提交给绝大多数权威机构进行处理，这也确保了证书效果的最终确定性。请注意，finality 晚于 fastpay \[3] 以确保重新配置下的安全性。但是，权威机构可以在看到证书时应用事务的效果，而不是等待提交。

4.4 所有者、授权和共享对象

交易有效性（参见第 4.3 节）确保交易被授权在交易中包含所有指定的输入对象。此检查取决于对象的性质以及所有者字段。

只读对象不能被改变或删除，并且可以在事务中同时被所有用户使用。例如，移动模块是只读的。此类对象确实有可能用作智能合约的一部分的所有者，但这不会影响使用它们的授权。它们可以包含在任何交易中拥有的对象有一个所有者字段,可以将所有者设置为代表公钥的地址。在这种情况下，交易被授权使用该对象并对其进行变异，如果它由该对象签名地址。交易由单个地址签名，因此可以使用该地址拥有的一个或多个对象。但是，单个事务不能使用由多个地址拥有的对象。一个对象（称为子对象）的所有者可以设置为另一个对象（称为父对象）的 ObjID。在这种情况下，只有当父对象包含在事务中并且事务被授权使用该对象时，才可以使用子对象。合约可以使用此工具来构建有效的集合和其他复杂的数据结构。

共享对象是可变的，但没有特定的所有者。相反，它们可以包含在不同方的交易中，并且不需要任何授权。相反，他们执行自己的授权逻辑。这样的对象，由于必须在确保安全性和活跃性的同时支持多个写入者，确实需要完整的协议协议才能安全使用。因此，它们在执行之前需要额外的逻辑。当局按照 Sect 中的规定处理交易。 4.3 为拥有对象和只读对象管理它们的锁。然而，权威不依赖一致的广播来管理共享对象的锁。相反，涉及共享对象的交易的创建者将交易上的证书插入到高吞吐量的共识系统中，例如\[9]。所有的权威机构都遵守这些证书的一致顺序，并根据该顺序分配每个事务使用的共享对象的版本。然后可以继续执行，并保证在所有当局之间保持一致。权限包括在效果证书中的事务执行中使用的共享对象的版本。

上述规则确保了涉及只读和拥有对象的交易的执行只需要一致的广播和单个证书即可进行；只有涉及共享对象的交易才需要拜占庭协议。因此，智能合约作者可以设计他们的类型和操作，以优化对单个用户对象的传输和其他操作，以降低延迟，同时享受使用共享对象实现需要由多个用户访问的逻辑的灵活性。

4.5 客户

完整的客户端和副本。副本，有时也称为完整客户端，不验证新交易，但出于审计目的维护系统有效状态的一致副本，以及构建交易或运营服务，包括。读取轻客户端查询的基础设施。

轻客户端:对象引用和事务都包含允许对导致它们创建或执行的事务的完整因果链进行身份验证的信息。具体来说，对象引用 (ObjRef) 包含一个 ObjDigest，它是对象完整状态的验证器，包括获取父对象 (Obj) 的工具，即创建对象的 TxDigest。类似地，TxDigest 验证交易，包括通过输入（Tx）提取对象引用的工具输入对象。因此，对象和证书的集合形成了一个自认证的二分图。此外，效果结构也被签名，并且可以被整理成直接证明交易执行结果的效果证书。

这些设施可用于支持轻客户端，这些客户端可以执行对 Sui 状态的高完整性读取，而无需维护完整的副本节点。具体来说，权威或全节点可以提供简洁的证据包，包括交易 Tx 上的证书 TxCert 和对应于输入（Tx）的输入对象 \[Obj]，以使轻客户端相信可以在 Sui 内发生转换。然后，轻客户端可以提交此证书，或检查它是否已被法定人数或权威样本查看以确保最终确定性。或者它可以使用执行产生的对象来制作交易，并观察它是否成功。

更直接地，服务可以向客户提供效果证书，以使他们相信 Sui 内的转换的存在和终结，而无需在系统内进行进一步的操作或交互。如果最终证书的检查点可用，在纪元边界或其他地方，包括输入对象和证书的一束证据，以及在检查点中包含证书的证明也是最终性证明。

当局可以使用定期检查点机制来创建最终交易的集体检查点，以及随时间推移的 Sui 状态。轻客户端可以使用在检查点上具有法定权益的证书来有效地验证对象的最近状态和发出的事件。检查点机制对于时期之间的委员会重新配置是必要的。更频繁的检查点对轻客户端很有用，也可以被当局用来压缩他们的内部数据结构，以及更有效地与其他当局同步他们的状态。

4.6 桥梁

对拜占庭协议管理的轻客户端和共享对象的原生支持允许 Sui 支持到其他区块链的双向桥接 \[13]。这种桥的信任假设反映了 Sui 和其他区块链的信任假设，如果其他区块链也支持轻客户端 \[7]，则不必依赖可信预言机或硬件。

Bridges 用于导入在另一个区块链上发布的资产，以表示它并将其用作 Sui 系统中的包装资产。最终，打包的资产可以被解锁并转移回本地区块链上的用户。 Bridges 还可以允许在 Sui 上发行的资产被锁定，并在其他区块链上用作包装资产。最终，其他系统上的包装对象可以被销毁，并且 Sui 上的对象更新以反映状态或所有权的任何更改，并解锁。

桥接资产的语义对于确保包装资产有用具有一定的重要性。跨区块链桥接的可替代资产可以提供更丰富的包装表示，允许它们在包装时可分割和可转移。不可替代资产不可分割，而只能转让。它们还可能支持在包装时以受控方式改变其状态的其他操作，这可能需要在桥接和解包时执行自定义智能合约逻辑。 Sui 很灵活，允许智能合约作者定义此类体验，因为桥接器只是在 Move 中实现的智能合约，而不是原生的 Sui 概念——因此可以使用 Move 提供的可组合性和安全保证进行扩展。

4.7 委员会重组

当委员会 𝐶𝑒 被委员会 𝐶𝑒′ 替换时，在 epoch 之间会发生重新配置，其中 𝑒′ = 𝑒 + 1。重新配置安全性确保如果在 𝑒 或更早之前提交了事务 Tx，则在 𝑒 之后不能提交冲突事务。 Liveness 确保如果 Tx 在 𝑒 或之前提交，那么它也必须在 𝑒 之后提交。

我们利用 Sui 智能合约系统来执行重新配置所需的大量工作。在 Sui 中，系统智能合约允许用户锁定并将权益委托给候选机构。在一个时期内，硬币的所有者可以通过锁定代币自由委托、通过解锁代币取消委托或将其委托更改为一个或多个权限。

一旦 epoch𝑒 的法定人数投票结束 epoch，当局就会交换信息以提交检查点，确定下一个委员会，并更改 epoch。首先，当局在协议协议 \[9] 的帮助下运行检查点协议，以在 epoch 结束时就经过认证的检查点达成一致。检查点包含已由法定人数处理的所有事务和可能产生的对象的联合。因此，如果一笔交易已经由法定人数的权威机构处理，那么至少有一个处理该交易的诚实权威机构会将其处理过的交易包含在时代结束检查点中，从而确保交易及其影响在各个时代都是持久的。此外，这样一个经过认证的检查点保证了所有交易都可供纪元𝑒的诚实当局使用。

然后使用在纪元结束检查点的权益委托来确定纪元𝑒 + 1 的新权限集。旧权限权益​​的法定人数和新权限权益的法定人数都签署了新委员会𝐶𝑒′，以及新纪元开始的检查点。一旦这两组签名都可用，新的权限集开始处理新纪元的交易，旧的权限可以删除它们的纪元签名密钥。

恢复:由于客户端错误或客户端模棱两可，拥有的对象可能会在一个时期内被“锁定”，从而阻止任何有关它的交易被认证（或最终确定）。例如，一个客户端使用相同的拥有对象版本签署两个不同的交易，每个交易有一半的权限签名，将无法形成一个需要法定人数签名的证书。两个证书中的任何一个。恢复确保一旦 epoch 发生变化，这些对象再次处于允许它们在事务中使用的状态。由于无法形成证书，因此原始对象在下一个要操作的时期开始时可用。由于交易包含一个纪元号，旧的模棱两可的交易不会再次锁定该对象，让其所有者有机会使用它。

奖励和加密经济学。 Sui 有一个原生代币 SUI，供应量固定。 SUI 用于支付 gas 费用，也可用作一个时期内授权的委托权益。在这个时期内，权威的投票权是这个委托权益的函数。在 epoch 结束时，通过所有处理的交易收取的费用根据他们对 Sui 运营的贡献分配给当局，然后他们将部分费用作为奖励分配给委托给他们的地址。我们将 Sui 的代币经济学的完整描述推迟到专门的论文中。

4.8 权威和副本更新

客户驱动。由于客户端故障或非拜占庭授权失败，某些授权可能未处理所有证书。因此，依赖于这些证书生成的缺失对象的因果相关交易将被拒绝。但是，客户始终可以将诚实的权威更新到能够处理正确交易的程度。它可以使用自己的过去证书存储，或使用一个或多个其他诚实的权威机构作为过去证书的来源来做到这一点。

给定一个证书 𝑐 和一个包含 𝑐 及其因果历史的 𝐶𝑡𝑣 存储，客户端可以将诚实的权威 𝑣′ 更新到也可以应用 𝑐 的程度。这涉及找到不在𝑣′中的最小证书集，这样当应用时，𝑣′中的对象包括𝑐的所有输入。使用包含证书 TxCert 的商店 𝐶𝑡𝑣 更新滞后的权威机构 𝐵 涉及：

• 客户端维护要同步的证书列表，最初设置为仅包含 TxCert。

• 客户端认为最后一个需要同步的 TxCert。它提取 TxCert 中的 Tx 并派生其所有输入对象（使用 Input(Tx)）。

• 对于每个输入对象，它检查最后生成或变异的 Tx（使用 𝐶𝑡𝑣 上的 Sync𝑣 索引）是否在 𝐵 中有证书，否则从𝐶𝑡𝑣 读取其证书并将其添加到要同步的证书列表中。

• 如果没有更多的证书可以添加到列表中（因为没有更多的输入从𝐵 中丢失），则证书列表按因果顺序排序并提交给𝐵。

上述算法也适用于将对象更新到特定版本以启用新事务。在这种情况下，生成对象版本的 Tx 的证书（在 Sync𝑣 \[ObjRef] 中找到）被提交给滞后机构。一旦是在 𝐵 上执行，正确版本的对象将可用。

执行此操作的客户端称为中继器。可以有多个中继器独立并同时运行。它们在完整性方面不受信任，并且它们的操作是无密钥的。除了客户端，权限可以运行中继器逻辑来相互更新，副本操作服务也可以充当中继器来更新滞后的权限。

块。当局为追随者在处理证书时接收更新提供了便利。这允许副本维护权威状态的最新视图。此外，当局可以使用推拉式八卦网络在短期内相互更新最新处理的交易，并减少中继器执行此功能的需要。从长远来看，滞后的当局可能会在时代边界或更频繁地使用定期状态承诺，以确保他们已经处理了直到某些检查点的完整证书集。

5 扩展和延迟

Sui 系统允许通过将更多资源（即一台机器内或多台机器上的 CPU、内存、网络和存储）用于处理事务的权限进行扩展。更多的资源会提高处理交易的能力，从而增加为这些资源提供资金的费用收入。更多的资源也会导致更低的延迟，因为无需等待必要的资源可用就可以执行操作。

吞吐量。为了确保更多资源以准线性方式增加容量，Sui 设计积极减少了瓶颈和需要在权限内全局锁定的同步点。处理事务被明确地分为两个阶段，即（1）确保事务对特定版本的拥有或共享对象具有独占访问权，以及（2）随后执行事务并提交其效果。

阶段 (1) 要求事务以对象的粒度获取分布式锁。对于拥有的对象，这是通过可靠的广播原语执行的，不需要权限内的全局同步，因此可以通过 ObjID 对多台机器的锁管理进行分片来扩展。对于涉及共享对象的事务，需要使用共识协议进行排序，该协议确实对这些事务施加了全局顺序，并且有可能成为瓶颈。然而，工程高吞吐量共识协议 \[9] 的最新进展表明，顺序执行是状态机复制的瓶颈，而不是排序。在 Sui 中，排序仅用于确定输入共享对象的版本，即递增对象版本号并将其与事务摘要相关联，而不是执行顺序执行。

阶段 (2) 发生在所有输入对象的版本为权威所知（并且在权威之间安全地达成一致）并且涉及 Move 交易的执行及其效果的承诺。一旦知道输入对象的版本，就可以完全并行执行。移动多核或物理机上的虚拟机读取版本化的输入对象、执行并将生成的对象写入存储。对象和事务的存储（除了顺序锁映射）的一致性要求非常宽松，允许每个权限内部使用可扩展的分布式键值存储。执行是幂等的，即使处理执行的组件发生崩溃或硬件故障也很容易恢复。

因此，彼此没有因果关系的事务的执行可以并行进行。因此，智能合约设计者可以在其合约中设计对象和操作的数据模型，以利用这种并行性。

检查点和状态承诺是根据关键事务处理路径计算的，不会阻止新事务的处理。这些涉及对已提交数据的读取操作，而不是在事务达到最终确定之前需要计算和协议。因此，它们不会影响处理新事务的延迟或吞吐量，并且它们本身可以分布在可用资源中。

读取可以从非常积极的、可扩展的缓存中受益。权威机构签署并提供轻客户端读取所需的所有数据，这些数据可以由分布式存储作为静态数据提供。证书作为交易和对象的完整因果历史的信任根。状态承诺进一步允许整个系统对所有状态和处理的交易具有定期的全球信任根，至少在每个时期或更频繁地处理。

潜伏。智能合约设计者可以灵活地控制他们定义的操作的延迟，具体取决于它们是否涉及拥有或共享的对象。拥有的对象在执行和提交之前依赖于可靠的广播，这需要两次往返到法定人数才能达到最终确定性。另一方面，涉及共享对象的操作需要一致的广播来创建证书，然后在共识协议中进行处理，从而导致延迟增加（截至 \[9] 需要 4 到 8 次往返仲裁）。

参考

\[1] Mustafa Al-Bassam、Alberto Sonnino、Vitalik Buterin 和 Ismail Khoffi。 2021. 欺诈和数据可用性证明：检测轻客户端中的无效块。在金融密码学和数据安全 - 第 25 届国际会议，FC 2021，虚拟活动，2021 年 3 月 1 日至 5 日，修订的选定论文，第二部分（计算机科学讲义，第 12675 卷），Nikita Borisov 和 Claudia Diaz（Eds. ）。施普林格，279–298。

\[2] Shehar Bano、Alberto Sonnino、Mustafa Al-Bassam、Sarah Azouvi、Patrick McCorry、Sarah Meiklejohn 和 George Danezis。 2019. SoK：区块链时代的共识。在第一届 ACM 金融技术进步会议论文集上，AFT 2019，瑞士苏黎世，2019 年 10 月 21-23 日。ACM，183-198。

\[3] Mathieu Baudet、George Danezis 和 Alberto Sonnino。 2020. FastPay：高性能拜占庭容错结算。在 AFT '20：第二届 ACM 金融技术进步会议上，美国纽约州纽约市，2020 年 10 月 21-23 日。ACM，163-177。

\[4] Sam Blackshear、Evan Cheng、David L. Dill、Victor Gao、Ben Maurer、Todd Nowacki、Alistair Pott、Shaz Qadeer、Ra in、Dario Russi、Stephane Sezer、Tim Zakian 和 Runtian Zhou。 2019. 移动：具有可编程资源的语言。 https://developers.libra.org/docs/move-paper。

\[5] Sam Blackshear、David L. Dill、Shaz Qadeer、Clark W. Barrett、John C. Mitchell、

Oded Padon 和 Yoni Zohar。 2020. 资源：一种安全的语言抽象

钱。 CoRR abs/2004.05106 (2020)。 arXiv:2004.05106 https://arxiv.org/abs/

2004.05106

\[6] Christian Cachin、Rachid Guerraoui 和 Luís Rodrigues。 2011. 可靠和安全的分布式编程简介。施普林格科学与商业媒体。

\[7] Panagiotis Chatzigiannis、Foteini Baldimtsi 和 Konstantinos Chalkias。 2021 年。

SoK：区块链轻客户端。 IACR 加密。电子打印拱门。 （2021 年），1657 年。

\[8] Daniel Collins、Rachid Guerraoui、Jovan Komatovic、Petr Kuznetsov、Matteo Monti、Matej Pavlovic、Yvonne-Anne Pignolet、Dragos-Adrian Seredinschi、Andrei Tonkikh 和 Athanasios Xygkis。 2020. 仅通过广播消息进行在线支付。在第 50 届年度 IEEE/IFIP 可靠系统和网络国际会议上，DSN 2020，西班牙瓦伦西亚，2020 年 6 月 29 日至 7 月 2 日。IEEE，26-38。

\[9] George Danezis、Eleftherios Kokoris-Kogias、Alberto Sonnino 和 Alexander Spiegelman。 2021. Narwhal 和 Tusk：基于 DAG 的内存池和高效的 BFT 共识。 CoRR abs/2105.11827 (2021)。

\[10] David L. Dill、Wolfgang Grieskamp、Junkil Park、Shaz Qadeer、Meng Xu 和 Jingyi Emma Zhong。 2021. 使用 Move Prover 对智能合约进行快速可靠的正式验证。 CoRR abs/2110.08362 (2021)。 arXiv:2110.08362 https://arxiv.org/abs/2110.08362

\[11] Rachid Guerraoui、Petr Kuznetsov、Matteo Monti、Matej Pavlovic 和 DragosAdrian Seredinschi。 2018. AT2：异步可信传输。 CoRR abs/1812.10844 (2018)。

\[12] Rachid Guerraoui、Petr Kuznetsov、Matteo Monti、Matej Pavlovic 和 Dragos-

阿德里安·塞雷丁斯基。 2019. 加密货币的共识编号。在 2019 年 ACM 分布式计算原理研讨会论文集上，PODC 2019，加拿大安大略省多伦多，2019 年 7 月 29 日至 8 月 2 日，Peter Robinson 和 Faith Ellen（主编）。 ACM，307-316。

\[13] Patrick McCorry、Chris Buckland、Bennet Yee 和黎明之歌。 2021. SoK：验证桥梁作为区块链的扩展解决方案。 IACR 加密。电子打印拱门。 （2021 年），1589 年。

\[14] 马尔科·帕特里尼亚尼和山姆·布莱克希尔。 2021. 强大的移动安全性。 CoRR abs/2110.05043 (2021)。 arXiv:2110.05043 https://arxiv.org/abs/2110.05043

\[15] 杰罗姆·H·萨尔策和迈克尔·D·施罗德。 1975. 计算机系统中的信息保护。过程。 IEEE 63, 9 (1975), 1278–1308。

\[16] Jingyi Emma Zhong、Kevin Cheang、Shaz Qadeer、Wolfgang Grieskamp、Sam Blackshear、Junkil Park、Yoni Zohar、Clark W. Barrett 和 David L. Dill。 2020 年。

移动证明者。在计算机辅助验证 - 第 32 届国际会议中，

CAV 2020，美国加利福尼亚州洛杉矶，2020 年 7 月 21 日至 24 日，会议记录，第一部分（计算机科学讲义，第 12224 卷），Shuvendu K. Lahiri 和 Chao Wang（主编）。

施普林格，137-150。 https://doi.org/10.1007/978-3-030-53288-8\_7
